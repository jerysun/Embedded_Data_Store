/*
 * filename: edatastore.h
 * describe: First of all, I want you to know that the goal of EDS (Embedded
 *           Data Store) in software industry is to
 *
 *           Make Efficiency Great Again!
 *
 *           The algorithm complexity of EDS even in the WORST cases, is still
 *                   O(log n)
 *           for insert, query and delete operations.
 * 
 *           The underlying technique of EDS - my customized B-Tree algorithm
 *           highly optimized for the state-of-the-art SSD Disk system is ba-
 *           sically implemented in C language, only wrapped by a thin C++
 *           layer, which is the interface for the EDS engine -  EDatastore
 *           which is written in STANDARD C++ without any third party depen-
 *           dency (libraries).
 *
 *           Generally, each datastore generated by EDS has two files with the
 *           extension name .eds and .idx no matter how many tables(objects)
 *           there are inside it, one is the data file another is the index
 *           file. So it's very convenient for you to migrate and deploy your
 *           applications to different machines and/or different platforms -
 *           just copy-and-paste the two files for each datastore. Of course,
 *           EDS supports multiple datastores running in one single application
 *           as well.
 *
 *           EDS is written in OO and for OO, thus it removes the ORM burden
 *           which works as a "middleman" between the applications and the tra-
 *           ditional RDBMS to make it more efficient and much easier for modern
 *           applications development. Objects ARE tables in EDS, many objects
 *           consist of a Datastore, neither SQL nor conversion between applica-
 *           tions and RDBMS are needed. Yes, it's just so simple and so direct
 *           and so INTUITIVE.
 * Author:   Jerry Sun <jerysun0818@gmail.com>
 * Date:     August 17, 2015
 * Remark:   EDS is ongoing, still evolves... The goal of EDS is not to replace
 *           the RDBMS that's suitable for large complex database applications
 *           and people who like and are good at SQL. EDS, just like the name
 *           hints, it aims at embedded system and applications, but so far it
 *           has flourished in desktop applications as well which delivery chan-
 *           nel are via Internet, because as a developer or software vendor:

 *           you don't have to buy and install the cumbersome relational database
 *           servers onsite for your clients;
 *           
 *           you don't have to ask your clients to buy and install the cumbersome
 *           relational database servers by themselves;
 *           
 *           you don't have to buy the dedicated relational database servers and
 *           install them at your company for your clients' connections and access
 *
 *           EDS wins in the efficiency and affinity with the frontline
 *           application developers.
 * Linkedin: http://nl.linkedin.com/in/jerysun
 * Website:  https://sites.google.com/site/geekssmallworld
 * Github:   https://github.com/jerysun/
 */

/* Copyright (c) 2017 Dates Great, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef EDATASTORE_H
#define EDATASTORE_H

#include <fstream>
#include <typeinfo>
#include <string>
#include <cstring>

/*
* EDatastore exceptions representing program errors
*/
// ReadObject from non-ctor
class EdsExceptions {};

// WriteObject from non-dtor
class NotInConstructor : public EdsExceptions {};

// No datastore open
class NotInDestructor : public EdsExceptions {};

// LoadObject was not called
class NoDatastore : public EdsExceptions {};

// SaveObject was not called
class NotLoaded : public EdsExceptions {};

// Multireference object deleted
class NotSaved : public EdsExceptions {};

// std::string key w/out size
class MustDestroy : public EdsExceptions {};

// Key length != btree key length
class ZeroLengthKey : public EdsExceptions {};
class BadKeylength : public EdsExceptions {};

// Bad reference object
class BadReference : public EdsExceptions {};

// Bad ObjAddr specified
class BadObjAddr : public EdsExceptions {};

// Class Identification
typedef int ClassID;

// Class Identification structure
struct Class {
  char *classname;
  ClassID classid;
  std::streampos headeraddr;
  Class(char *cn = 0) : classname(cn), classid(0), headeraddr(0) {}
};

// Key Controls
typedef int IndexNo;
typedef int KeyLength;

#include "linklist.h"
#include "btree.h"

// Object Address
struct ObjAddr {
  NodeNbr oa;
  ObjAddr(NodeNbr nd = 0) : oa(nd) {}
  operator NodeNbr() const {
    return oa;
  }
};

// Serialize Object Header Rcd
struct ObjectHeader {
  ClassID classid;  // class identification
  NodeNbr ndnbr;    // relative node number within object
  ObjectHeader() : classid(0), ndnbr(0) {}
};

class EDatastore;

// Serialize object abstract base class
class Serialize {
public:
  // These are public members because template functions cannot be
  // friends or member functions, and some template functions need
  // to call them. Users should not call these member functions.
  static Serialize *ObjectBeingConstructed() throw (NotInConstructor);
  static Serialize *ObjectBeingDestroyed() throw (NotInDestructor);
  void EdsReadObject(void *buf, int length);
  void EdsWriteObject(const void *buf, int length);
  void ReadStrObject(std::string& str);
  void WriteStrObject(const std::string& str);
  // s/b called only from Reference template
  void AddReference() {
    ++instances;
  }
protected:
  Serialize();
  Serialize(EDatastore* db);
  virtual ~Serialize() throw (NotLoaded, NotSaved, MustDestroy);
  // provided by derived class
  virtual void Write() = 0;
  virtual void Read() = 0;
  // called from derived class's constructor
  void LoadObject(ObjAddr nd = 0);
public:
  // called from derived class's destructor or by user to
  // force output to datastore
  void SaveObject() throw (NoDatastore);

  // class interface methods for modifying datastore
  bool AddObject();
  bool ChangeObject();
  bool DeleteObject();
  bool ObjectExists() const {
    return objectaddress != 0;
  }

  // class interface methods for searching datastore
  Serialize& FindObject(EdsKey *key);
  Serialize& CurrentObject(EdsKey *key = 0);
  Serialize& FirstObject(EdsKey *key = 0);
  Serialize& LastObject(EdsKey *key = 0);
  Serialize& NextObject(EdsKey *key = 0);
  Serialize& PreviousObject(EdsKey *key = 0);
  // return the object identification
  ObjAddr ObjectAddress() const {
    return objectaddress;
  }
  // pseudo delete operator for multiple instances
  static void Destroy(Serialize *pp);

private:
  // private copy constructor & assignment prevent copies
  Serialize(const Serialize&) {}
  Serialize& operator=(const Serialize&) {
    return *this;
  }

  // methods used from within Serialize class
  void RegisterKey(EdsKey *key) {
    keys.AppendEntry(key);
  }
  void ObjectOut();
  void RecordObject();
  void RemoveObject();
  void RemoveOrgKeys();
  void AddIndexes();
  void DeleteIndexes();
  void UpdateIndexes();
  void PositionNode() throw (BadObjAddr);
  void ReadObjectHeader();
  void WriteObjectHeader();
  void SearchIndex(EdsKey *key);
  void ReadDataMembers();
  EdsBtree *FindIndex(EdsKey *key);
  bool TestRelationships();
  void ScanForward(NodeNbr nd);
  void ScanBackward(NodeNbr nd);
  void BuildObject() throw (NoDatastore);
  void TestDuplicateObject() throw (Serialize*);
private:
  friend class EDatastore;
  friend class EdsKey;
  friend class EdsReference;
  ObjectHeader objhdr;
  ObjAddr objectaddress; // Node address for this object
  EDatastore* edatastore;        // datastore for this object
  int indexcount;  // number of keys in the object
  int instances;   // number of instances of object
  Node *node;            // current node for reading/writing
  int offset;      // current char position
  bool changed;          // true if user changed the object
  bool deleted;          // true if user deleted the object
  bool newobject;        // true if user is adding the object
  bool loaded;           // true if LoadObject called
  bool saved;            // true if SaveObject called
  static bool usingnew;  // true if object built with new
  std::streampos filepos;// for saving file position

  // pointers to associate keys with objects
  Serialize *prevconstructed;
  static Serialize *objconstructed;
  static Serialize *objdestroyed;

  LinkedList<EdsKey> keys;
  LinkedList<EdsKey> orgkeys; // original keys in the object
};

// DataFile class
class DataFile : public NodeFile {
public:
  DataFile(const std::string& name) : NodeFile(name + ".eds") {}
};

// the EDatastore datastore
class EDatastore {
public:
  EDatastore(const std::string& name);
  ~EDatastore();
  static EDatastore *OpenDatastore() {
    return opendatastore;
  }
private:
  void GetObjectHeader(ObjAddr nd, ObjectHeader& objhdr);
  void RebuildIndexes(ObjAddr nd) {
    rebuildnode = nd;
  }
  bool FindClass(Class *cls, NodeNbr *nd = 0);
  ClassID GetClassID(const char *classname);
  // friend void BuildIndex();
  // private copy constructor & assignment prevent copies
  EDatastore(const EDatastore&) : datafile(std::string()), indexfile(std::string()) {}
  EDatastore& operator=(const EDatastore&) {
    return *this;
  }
  void RegisterIndexes(Class *cls, const Serialize& pcls) throw (ZeroLengthKey);
  ClassID RegisterClass(const Serialize& cls);
  Class *Registration(const Serialize& pcls);
  void AddClassToIndex(Class *cls);
private:
  friend Serialize;
  DataFile datafile;              // the object datafile
  IndexFile indexfile;            // the b-tree file
  LinkedList<Serialize> objects; // instantiated objects
  LinkedList<Class> classes;      // registered classes
  LinkedList<EdsBtree> btrees;    // btrees in the datastore
                                  // for Index program to rebuild indexes
  ObjAddr rebuildnode;            // object being rebuilt
  EDatastore *previousdatastore;       // previous open datastore
  static EDatastore *opendatastore;    // latest open datastore
};

// Serialize constructor using last declared datastore
inline Serialize::Serialize() : edatastore(EDatastore::OpenDatastore()) {
  BuildObject();
}

// Serialize constructor using specified datastore
inline Serialize::Serialize(EDatastore* db) : edatastore(db) {
  BuildObject();
}

template <class T>
void ReadObject(T& t) {
  Serialize *oc = Serialize::ObjectBeingConstructed();
  oc->EdsReadObject(&t, sizeof(T));
}

template <class T>
void WriteObject(const T& t) {
  Serialize *od = Serialize::ObjectBeingDestroyed();
  od->EdsWriteObject(&t, sizeof(T));
}

inline void ReadObject(std::string& s) {
  Serialize *oc = Serialize::ObjectBeingConstructed();
  oc->ReadStrObject(s);
}

inline void WriteObject(const std::string& s) {
  Serialize *od = Serialize::ObjectBeingDestroyed();
  od->WriteStrObject(reinterpret_cast<const std::string&>(s));
}

// SerializeObject template
template <class T>
class SerializeObject : public Serialize {
public:
  T Obj;
  SerializeObject(const T& obj) : Obj(obj) {
    LoadObject();
  }
  SerializeObject(ObjAddr oa = 0) {
    LoadObject(oa);
  }
  virtual ~SerializeObject() {
    SaveObject();
  }
private:
  void Read() {
    EdsReadObject(reinterpret_cast<void*>(&Obj), sizeof(T));
  }
  void Write() {
    EdsWriteObject(reinterpret_cast<void*>(&Obj), sizeof(T));
  }
};

// Reference template
template <class T>
class Reference {
public:
  T *obj;
  Reference();
  ~Reference();
  void ReadObject();
  void WriteObject();
  void operator=(T& to) throw (BadReference);
  void RemoveReference();
};

template <class T>
Reference<T>::Reference() {
  obj = 0;
}

template <class T>
Reference<T>::~Reference() {
  Serialize::Destroy(obj);
}

template <class T>
void Reference<T>::ReadObject() {
  Serialize::Destroy(obj);
  obj = 0;

  ObjAddr oa;
  ::ReadObject(oa);
  if (oa != 0) {
    obj = new T(oa);
  }
}

template <class T>
void Reference<T>::WriteObject() {
  ObjAddr oa = 0;
  if (obj != 0) {
    oa = obj->ObjectAddress();
  }
  ::WriteObject(oa);
}

template <class T>
void Reference<T>::operator=(T& to) throw (BadReference) {
  Serialize *po = dynamic_cast<Serialize*>(&to);
  if (po == 0) {
    throw BadReference();
  }
  Serialize::Destroy(obj);
  obj = static_cast<T*>(po);
  obj->AddReference();
}

template <class T>
void Reference<T>::RemoveReference() {
  Serialize::Destroy(obj);
  obj = 0;
}

#include "key.h"

#endif //EDATASTORE_H